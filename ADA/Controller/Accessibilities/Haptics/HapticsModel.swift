//
//  HapticsModel.swift
//  ADA
//
//  Created by sharun on 19/07/21.
//

import UIKit

enum NotificationFeedbackType: String {
    case success, warning, error
}

enum ImpactFeedbackType: String {
    case light, soft, medium, rigid, heavy
}

struct HapticsModel {
    let navigationTitle: String
    let introductionLabel: String
    var prepareLabel: NSAttributedString = NSAttributedString()
    var settingsLabel: NSAttributedString = NSAttributedString()
    var notificationLabel: NSAttributedString = NSAttributedString()
    var impactLabel: NSAttributedString = NSAttributedString()
    var selectionLabel: NSAttributedString = NSAttributedString()
    init() {
        navigationTitle = "Haptics Demo"
        introductionLabel = "iOS 10 introduced new ways of generating haptic feedback using predefined vibration patterns shared by all apps, thus helping users understand that various types of feedback carry special significance. The core of this functionality is provided by UIFeedbackGenerator, but that's just an abstract class â€“ the three classes you really care about are:" + "\n\n" +
            "1. UINotificationFeedbackGenerator" + "\n" +
            "2. UIImpactFeedbackGenerator" + "\n" +
            "3. UISelectionFeedbackGenerator"
        prepareLabel = attributedText(withString: "Preparing the Generator: \n\nHaptic feedback is generated by the taptic engine, a piece of hardware embedded in the device. To save power, the taptic engine is idle if it has nothing to do. It takes some time for the taptic engine to wake up and that can result in a slight delay. To reduce that delay, you can ask the feedback generator to prepare the taptic engine by invoking prepare() on the feedback generator. Calling prepare() is optional, though. You can also generate haptic feedback without first calling prepare on the feedback generator.", boldStrings: ["Preparing the Generator:"])
        settingsLabel = attributedText(withString: "To turn on 3D or Haptic Touch and adjust the sensitivity:" + "\n" +
            "1. Go to Settings and tap Accessibility.Tap Touch, then tap 3D & Haptic Touch. \n2. Depending on the device you have, you might see 3D Touch or Haptic Touch only. \n3. Turn on the feature, then use the slider to select a sensitivity level. ", boldStrings: ["To turn on 3D or Haptic Touch and adjust the sensitivity"])
        notificationLabel = attributedText(withString: "UINotificationFeedbackGenerator:" + "\n\n" + "The haptic feedback is generated by an instance of the UINotificationFeedbackGenerator class. This class creates haptics to communicate successes, failures, and warnings." + "\n\n" + "Implementation:" + "\n\n" + "UINotificationFeedbackGenerator().notificationOccurred(.success)", boldStrings: ["UINotificationFeedbackGenerator:", "Implementation:"])
        impactLabel = attributedText(withString: "UIImpactFeedbackGenerator:" + "\n\n" + "The haptic feedback is generated by an instance of the UIImpactFeedbackGenerator class. This class is used to simulate physical impacts, for example, objects colliding or a user interface element snapping into place. The light, medium, and heavy feedback styles are pretty descriptive. Apple introduced soft and rigid in iOS 13." + "\n\n" + "Implementation:" + "\n\n" + "UIImpactFeedbackGenerator(style: .light).impactOccurred())", boldStrings: ["UIImpactFeedbackGenerator:", "Implementation:"])
        selectionLabel = attributedText(withString: "UISelectionFeedbackGenerator:" + "\n\n" + "As the name suggests, this type of haptic feedback should be used to communicate that a change in selection took place. Apple's Clock application is a fine example. To set a timer, you interact with a picker view. Every time the selection changes, the application generates haptic feedback using the UISelectionFeedbackGenerator class. Several UIKit components have built-in support for haptic feedback, including UIDatePicker, UISwitch and UIPickerView." + "\n\n" + "Implementation:" + "\n\n" + "UISelectionFeedbackGenerator().selectionChanged()", boldStrings: ["UISelectionFeedbackGenerator:", "Implementation:"])
    }
    
    /// This function is responsible for getting the attributed string
    /// - Parameters:
    ///   - string: String
    ///   - boldStrings: Array of strings that needs to made bold
    /// - Returns: Attributed String
    func attributedText(withString string: String, boldStrings: [String]) -> NSAttributedString {
        let attributedString = NSMutableAttributedString(string: string)
        let boldFontAttribute: [NSAttributedString.Key: Any] = [NSAttributedString.Key.font: UIFont.boldSystemFont(ofSize: 20)]
        for boldString in boldStrings {
            let range = (string as NSString).range(of: boldString)
            attributedString.addAttributes(boldFontAttribute, range: range)
        }
        return attributedString
    }
}
